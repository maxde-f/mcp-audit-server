"""
Claude Memory System for Audit Workspaces

Provides persistent memory across Claude sessions:
- Context preservation
- Decision tracking
- Learning from feedback
- Project-specific knowledge
"""
import json
import logging
from dataclasses import dataclass, field, asdict
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict, List, Optional
from uuid import uuid4

logger = logging.getLogger(__name__)


@dataclass
class MemoryEntry:
    """Single memory entry."""
    id: str
    type: str  # context, decision, learning, fact, error
    content: str
    metadata: Dict[str, Any] = field(default_factory=dict)
    created_at: str = ""
    access_count: int = 0

    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now(timezone.utc).isoformat()

    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "MemoryEntry":
        return cls(**data)


@dataclass
class Decision:
    """Architectural or design decision."""
    id: str
    title: str
    context: str
    decision: str
    consequences: List[str] = field(default_factory=list)
    alternatives: List[str] = field(default_factory=list)
    status: str = "accepted"  # accepted, deprecated, superseded
    created_at: str = ""

    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now(timezone.utc).isoformat()

    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Decision":
        return cls(**data)


@dataclass
class LearningEvent:
    """Learning from mistakes or feedback."""
    id: str
    what_happened: str
    what_learned: str
    correction: Optional[str] = None
    pattern: Optional[str] = None
    created_at: str = ""

    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now(timezone.utc).isoformat()

    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "LearningEvent":
        return cls(**data)


class ClaudeMemory:
    """
    Persistent memory for Claude across sessions.

    Structure:
    .claude/
    ├── CLAUDE.md           # Instructions for Claude
    ├── memory.json         # Working memory
    ├── decisions.json      # ADR-style decisions
    ├── learnings.json      # Learning events
    ├── context.json        # Current context
    └── sessions/           # Session history
        └── {session_id}.json
    """

    def __init__(self, workspace_path: Path):
        self.workspace_path = Path(workspace_path)
        self.claude_dir = self.workspace_path / ".claude"

        self._memory: List[MemoryEntry] = []
        self._decisions: List[Decision] = []
        self._learnings: List[LearningEvent] = []
        self._context: Dict[str, Any] = {}

        self._ensure_structure()
        self._load()

    def _ensure_structure(self):
        """Create .claude directory structure."""
        self.claude_dir.mkdir(parents=True, exist_ok=True)
        (self.claude_dir / "sessions").mkdir(exist_ok=True)

        # Create CLAUDE.md if not exists
        claude_md = self.claude_dir / "CLAUDE.md"
        if not claude_md.exists():
            self._create_claude_md()

    def _create_claude_md(self):
        """Create CLAUDE.md instructions file."""
        content = f"""# Claude Instructions for {self.workspace_path.name}

## Project Overview
This is an audit workspace managed by audit-platform.

## Memory System
Your memory is persisted in this `.claude/` directory:
- `memory.json` - Working memory (facts, context)
- `decisions.json` - Architectural decisions (ADR format)
- `learnings.json` - What you've learned from mistakes
- `context.json` - Current session context
- `sessions/` - Historical sessions

## How to Use Memory

### Remember a fact
```
Use store_memory() to save important facts
```

### Record a decision
```
Use record_decision() for architectural choices
```

### Learn from mistakes
```
Use record_learning() when you make/fix errors
```

## Current Context
Check `context.json` for:
- Active analysis
- Current topic
- Recent actions

## Conventions
- Always read context.json at session start
- Update memory when discovering important facts
- Record decisions that affect project structure
- Learn from corrections user provides

## Project-Specific Notes
<!-- Add project-specific instructions here -->

---
*Auto-generated by audit-platform*
*Last updated: {datetime.now().strftime('%Y-%m-%d %H:%M')}*
"""
        (self.claude_dir / "CLAUDE.md").write_text(content)

    def _load(self):
        """Load all memory from files."""
        # Memory
        memory_file = self.claude_dir / "memory.json"
        if memory_file.exists():
            try:
                data = json.loads(memory_file.read_text())
                self._memory = [MemoryEntry.from_dict(e) for e in data.get("entries", [])]
            except (json.JSONDecodeError, KeyError):
                self._memory = []

        # Decisions
        decisions_file = self.claude_dir / "decisions.json"
        if decisions_file.exists():
            try:
                data = json.loads(decisions_file.read_text())
                self._decisions = [Decision.from_dict(d) for d in data.get("decisions", [])]
            except (json.JSONDecodeError, KeyError):
                self._decisions = []

        # Learnings
        learnings_file = self.claude_dir / "learnings.json"
        if learnings_file.exists():
            try:
                data = json.loads(learnings_file.read_text())
                self._learnings = [LearningEvent.from_dict(l) for l in data.get("learnings", [])]
            except (json.JSONDecodeError, KeyError):
                self._learnings = []

        # Context
        context_file = self.claude_dir / "context.json"
        if context_file.exists():
            try:
                self._context = json.loads(context_file.read_text())
            except json.JSONDecodeError:
                self._context = {}

    def _save_memory(self):
        """Save memory to file."""
        data = {"entries": [e.to_dict() for e in self._memory]}
        (self.claude_dir / "memory.json").write_text(json.dumps(data, indent=2))

    def _save_decisions(self):
        """Save decisions to file."""
        data = {"decisions": [d.to_dict() for d in self._decisions]}
        (self.claude_dir / "decisions.json").write_text(json.dumps(data, indent=2))

    def _save_learnings(self):
        """Save learnings to file."""
        data = {"learnings": [l.to_dict() for l in self._learnings]}
        (self.claude_dir / "learnings.json").write_text(json.dumps(data, indent=2))

    def _save_context(self):
        """Save context to file."""
        (self.claude_dir / "context.json").write_text(json.dumps(self._context, indent=2))

    # =========================================================================
    # Memory Operations
    # =========================================================================

    def store_memory(
        self,
        content: str,
        type: str = "fact",
        **metadata
    ) -> MemoryEntry:
        """Store a memory entry."""
        entry = MemoryEntry(
            id=str(uuid4())[:8],
            type=type,
            content=content,
            metadata=metadata,
        )
        self._memory.append(entry)
        self._save_memory()

        logger.info(f"Stored memory: {entry.id} ({type})")
        return entry

    def recall(
        self,
        query: Optional[str] = None,
        type: Optional[str] = None,
        limit: int = 10
    ) -> List[MemoryEntry]:
        """Recall memories, optionally filtered."""
        results = self._memory

        if type:
            results = [e for e in results if e.type == type]

        if query:
            query_lower = query.lower()
            results = [e for e in results if query_lower in e.content.lower()]

        # Sort by access count and recency
        results = sorted(results, key=lambda e: (e.access_count, e.created_at), reverse=True)

        # Update access count
        for entry in results[:limit]:
            entry.access_count += 1
        self._save_memory()

        return results[:limit]

    def forget(self, memory_id: str) -> bool:
        """Remove a memory entry."""
        for i, entry in enumerate(self._memory):
            if entry.id == memory_id:
                del self._memory[i]
                self._save_memory()
                return True
        return False

    # =========================================================================
    # Decision Records (ADR-style)
    # =========================================================================

    def record_decision(
        self,
        title: str,
        context: str,
        decision: str,
        consequences: Optional[List[str]] = None,
        alternatives: Optional[List[str]] = None,
    ) -> Decision:
        """Record an architectural/design decision."""
        dec = Decision(
            id=str(uuid4())[:8],
            title=title,
            context=context,
            decision=decision,
            consequences=consequences or [],
            alternatives=alternatives or [],
        )
        self._decisions.append(dec)
        self._save_decisions()

        # Also save as markdown
        self._save_decision_md(dec)

        logger.info(f"Recorded decision: {dec.id} - {title}")
        return dec

    def _save_decision_md(self, dec: Decision):
        """Save decision as markdown file."""
        decisions_dir = self.claude_dir / "decisions"
        decisions_dir.mkdir(exist_ok=True)

        content = f"""# {dec.title}

**ID:** {dec.id}
**Date:** {dec.created_at[:10]}
**Status:** {dec.status}

## Context
{dec.context}

## Decision
{dec.decision}

## Consequences
{chr(10).join(f'- {c}' for c in dec.consequences) or '- None documented'}

## Alternatives Considered
{chr(10).join(f'- {a}' for a in dec.alternatives) or '- None documented'}
"""
        (decisions_dir / f"{dec.id}_{dec.title.lower().replace(' ', '_')[:30]}.md").write_text(content)

    def get_decisions(
        self,
        status: Optional[str] = None,
        limit: int = 20
    ) -> List[Decision]:
        """Get recorded decisions."""
        results = self._decisions

        if status:
            results = [d for d in results if d.status == status]

        return sorted(results, key=lambda d: d.created_at, reverse=True)[:limit]

    # =========================================================================
    # Learning Events
    # =========================================================================

    def record_learning(
        self,
        what_happened: str,
        what_learned: str,
        correction: Optional[str] = None,
        pattern: Optional[str] = None,
    ) -> LearningEvent:
        """Record a learning event (from mistake or feedback)."""
        event = LearningEvent(
            id=str(uuid4())[:8],
            what_happened=what_happened,
            what_learned=what_learned,
            correction=correction,
            pattern=pattern,
        )
        self._learnings.append(event)
        self._save_learnings()

        logger.info(f"Recorded learning: {event.id}")
        return event

    def get_learnings(self, limit: int = 20) -> List[LearningEvent]:
        """Get learning events."""
        return sorted(self._learnings, key=lambda l: l.created_at, reverse=True)[:limit]

    # =========================================================================
    # Context Management
    # =========================================================================

    def set_context(self, key: str, value: Any):
        """Set a context value."""
        self._context[key] = value
        self._context["updated_at"] = datetime.now(timezone.utc).isoformat()
        self._save_context()

    def get_context(self, key: Optional[str] = None) -> Any:
        """Get context value or full context."""
        if key:
            return self._context.get(key)
        return self._context

    def clear_context(self):
        """Clear current context."""
        self._context = {"cleared_at": datetime.now(timezone.utc).isoformat()}
        self._save_context()

    def update_context(self, **kwargs):
        """Update multiple context values."""
        self._context.update(kwargs)
        self._context["updated_at"] = datetime.now(timezone.utc).isoformat()
        self._save_context()

    # =========================================================================
    # Session Management
    # =========================================================================

    def save_session(
        self,
        session_id: str,
        messages: List[Dict[str, Any]],
        summary: Optional[str] = None,
    ):
        """Save a session for later reference."""
        session_file = self.claude_dir / "sessions" / f"{session_id}.json"

        data = {
            "session_id": session_id,
            "saved_at": datetime.now(timezone.utc).isoformat(),
            "messages_count": len(messages),
            "messages": messages[-50:],  # Keep last 50
            "summary": summary,
        }

        session_file.write_text(json.dumps(data, indent=2))
        logger.info(f"Saved session: {session_id}")

    def load_session(self, session_id: str) -> Optional[Dict[str, Any]]:
        """Load a previous session."""
        session_file = self.claude_dir / "sessions" / f"{session_id}.json"

        if not session_file.exists():
            return None

        try:
            return json.loads(session_file.read_text())
        except json.JSONDecodeError:
            return None

    def list_sessions(self, limit: int = 10) -> List[Dict[str, Any]]:
        """List recent sessions."""
        sessions_dir = self.claude_dir / "sessions"
        sessions = []

        for f in sorted(sessions_dir.glob("*.json"), reverse=True):
            try:
                data = json.loads(f.read_text())
                sessions.append({
                    "session_id": data.get("session_id"),
                    "saved_at": data.get("saved_at"),
                    "messages_count": data.get("messages_count"),
                    "summary": data.get("summary"),
                })
            except:
                continue

            if len(sessions) >= limit:
                break

        return sessions

    # =========================================================================
    # Context Building for LLM
    # =========================================================================

    def build_context_prompt(self) -> str:
        """Build context prompt for Claude from memory."""
        parts = []

        # Current context
        if self._context:
            parts.append("## Current Context")
            for k, v in self._context.items():
                if k not in ("updated_at", "cleared_at"):
                    parts.append(f"- **{k}**: {v}")
            parts.append("")

        # Recent decisions
        recent_decisions = self.get_decisions(limit=3)
        if recent_decisions:
            parts.append("## Recent Decisions")
            for d in recent_decisions:
                parts.append(f"- **{d.title}**: {d.decision[:100]}...")
            parts.append("")

        # Relevant learnings
        recent_learnings = self.get_learnings(limit=3)
        if recent_learnings:
            parts.append("## Learnings (avoid these mistakes)")
            for l in recent_learnings:
                parts.append(f"- {l.what_learned}")
            parts.append("")

        # Important facts
        facts = self.recall(type="fact", limit=5)
        if facts:
            parts.append("## Important Facts")
            for f in facts:
                parts.append(f"- {f.content}")
            parts.append("")

        return "\n".join(parts)

    # =========================================================================
    # Export/Import
    # =========================================================================

    def export_all(self) -> Dict[str, Any]:
        """Export all memory data."""
        return {
            "memory": [e.to_dict() for e in self._memory],
            "decisions": [d.to_dict() for d in self._decisions],
            "learnings": [l.to_dict() for l in self._learnings],
            "context": self._context,
            "exported_at": datetime.now(timezone.utc).isoformat(),
        }

    def import_all(self, data: Dict[str, Any]):
        """Import memory data."""
        if "memory" in data:
            self._memory = [MemoryEntry.from_dict(e) for e in data["memory"]]
            self._save_memory()

        if "decisions" in data:
            self._decisions = [Decision.from_dict(d) for d in data["decisions"]]
            self._save_decisions()

        if "learnings" in data:
            self._learnings = [LearningEvent.from_dict(l) for l in data["learnings"]]
            self._save_learnings()

        if "context" in data:
            self._context = data["context"]
            self._save_context()

    def get_stats(self) -> Dict[str, Any]:
        """Get memory statistics."""
        return {
            "memory_entries": len(self._memory),
            "decisions": len(self._decisions),
            "learnings": len(self._learnings),
            "context_keys": len(self._context),
            "sessions": len(list((self.claude_dir / "sessions").glob("*.json"))),
        }
